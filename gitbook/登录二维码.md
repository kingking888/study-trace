# 微信逆向-登录二维码实战笔记

## 关于PNG格式

参考：PNG文件头格式解析 https://blog.csdn.net/satanzw/article/details/38757121

```hex
00000000h: 89 50 4E 47 0D 0A 1A 0A00 00 00 0D49 48 44 52 ; 塒NG........IHDR
00000010h: 00 00 00 CE 00 00 00 CE 08 02 00 00 00 F9 7D AA ; ...?..?....鶀?
00000020h: 93 00 00 00 09 70 48 59 73 00 00 0A 75 00 00 0A ; ?...pHYs...u...
00000030h: 75 01 4A 25 DD FD 00 00 0C 91 49 44 41 54 78 9C ; u.J%蔟...慖DATx?
00000040h: ED 9D D9 96 DC 2A 0C 45 A9 AC FC FF 2F D7 7D 70 ; 頋贃?.E┈?/讅p
00000050h: C7 97 66 10 9A 98 CF 7E C8 EA 54 95 6D 86 83 24 ; 菞f.殬蟸汝T昺唭$
00000060h: 04 B6 3F DF EF 37 00 D0 9F 3F B3 0B 00 6E 01 52 ; .?唢7.袩??.n.R
00000070h: 03 83 F8 3B BB 00 AB F2 F9 98 0E 47 58 92 01 A9 ; .凐;?鶚.GX?? 
```

89 50 4E 47 0D 0A 1A 0A 是PNG头部署名域，表示这是一个PNG图片
00 00 00 0D 描述IHDR头部的大小
49 48 44 52 是Chunk Type Code, 这里Chunk Type Code=IHDR

即，只要是PNG，内存里面一定有IHDR的标识，-8个字节地址，得到png的起始地址。视频里面“智能编辑->-c”就是自动探测png格式，然后算出起始地址的意思。

## 登录二维码基址

### 找基址

参考：[PC微信逆向：使用HOOK拦截二维码](https://blog.csdn.net/qq_38474570/article/details/92798577)

二维码指针（结构体）：049C428C -> 0482EB90

ESI+0：049C428C 二维码图片地址

Call的地址：
地址        特征码           汇编代码
53CF2459    E8 9263D200     call WeChatWi.54A187F0

WeChatWin.dll 模块基址：53780000

找到的基址如下：
```c++
// WeChatWin.dll(2020-12-24) 3.1.0.67
hook偏移：0x53CF2459 - 模块基址（0x53780000）= 0x572459
call偏移：0x54A187F0 - 模块基址（0x53780000）= 0x12987F0
```

即：
- 二维码内容Hook地址：**WeChatWin.dll+0x572459**
- 二维码


7A5D2459    E8 9263D200     call WeChatWi.7B2F87F0                   ; hook这里

E8: call
9263D200：计算公式=要跳转的地址 - hook地址 - 5（地址4字节+1字节指令）

E9: jmp

```c++
7A5D2458    50              push eax
//7A5D2459    E8 9263D200     call WeChatWi.7B2F87F0                   ; hook这里
//          E9 自己函数的地址
//          pic = ESI
//          show 
//          ...
//          jmp 7A5D245E
7A5D245E    83C4 0C         add esp,0xC
```

## 实战

### 流程

1. 执行完call WeChatWi.54A187F0
2. 通过ESI+0得到二维码结构体地址
3. +4字节得到二维码图片大小

### 关于寄存器备份

原始写法：
```c++
dword_t pEax;
dword_t pEcx;
dword_t pEdx;
dword_t pEbx;
dword_t pEsp;
dword_t pEbp;
dword_t pEsi;
dword_t pEdi;
// 备份8个寄存器
__asm{
    mov pEax, eax
    mov pEcx, ecx
    mov pEdx, edx
    mov pEbx, ebx
    mov pEsp, esp
    mov pEbp, ebp
    mov pEsi, esi
    mov pEdi, edi
}

// to do

// 还原8个寄存器
__asm {
    mov eax, pEax
    mov ecx, pEcx
    mov edx, pEdx
    mov ebx, pEbx
    mov esp, pEsp
    mov ebp, pEbp
    mov esi, pEsi
    mov edi, pEdi
}
```

实际中，为了方便，快捷写法如下：
```c++
__asm{
    pushad
    pushfd
}

// 处理代码

__asm {
    popfd
    popad
}
```

说明：  
- pushad：将所有的32位通用寄存器压入堆栈
- pushfd：然后将32位标志寄存器EFLAGS压入堆栈
- popad：将所有的32位通用寄存器取出堆栈
- popfd：将32位标志寄存器EFLAGS取出堆栈

### 关于备份代码

#### 使用memcpy手动拷贝

如下：
```c++
BYTE backCode[5] = { 0 };

// 保存以前的属性用于还原
DWORD OldProtext = 0;

// 因为要往代码段写入数据，又因为代码段是不可写的，所以需要修改属性
VirtualProtect((LPVOID)dwHookAddr, 5, PAGE_EXECUTE_READWRITE, &OldProtext);

//保存原有的指令
memcpy(backCode, (void*)dwHookAddr, 5);

//写入自己的代码
memcpy((void*)dwHookAddr, jmpCode, 5);

// 执行完了操作之后需要进行还原
VirtualProtect((LPVOID)dwHookAddr, 5, OldProtext, &OldProtext);
```

#### 通过WindowsAPI

windows提供了2个API可以快速读写进程内存：
- ReadProcessMemory：
- WriteProcessMemory：